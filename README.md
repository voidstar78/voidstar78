Greetings!  I've been programming since 1986.

For more about me, see
http://voidstar.blog

Some of my hobbies have been: stone sculpting, astrophotography, 3D printing, vintage computing.  After my daughter was born, I learned to play Pokemon, and we've traveled to many places together.

One project I've always wanted to collaborate on is trying ti discover the "next" thing "high-level programming languages."  Some people thought UML was that, by coupling design and implementation into "easy" to understand diagrams with a standard set of symbols.  Perhaps UML was just ahead of its time, since just like you can end up with "speghetti code" the UML diagrams generally just resulted in "speghetti diagrams."   You just couldn't depict that much information in a 2D plane.  People would plot UML diagrams using plotters, it was ridiculous.

Things like syntax highlighting and auto-complete have been instrumental in helping people code, and very useful incremental improvements to "how we do business" in programming.  But I still feel there "a better way" still out there.  My biggest grip is that software managers have no insight to the code-base that they manage.  Reading takes a lot of time and effort, and software is more like writing a book than constructing a building.  But a software manager can't quickly "walk the floor" and get a good feel for where the software development progress is, where the trouble spots are, or what aspects need more attention.   We do have processes that help - spirals, demos, scrums, and all that.   But it's still very easy for software to just "do what it is suppose to do", even if the cost in how it does that is very high (i.e. very inefficient).   I believe the next "evolution" needs to help in providing insight into how efficient a piece of software is, even down to registers.

So how do we mirror those two extreme: machine language efficiency and abstract intent.  And high-level languages have so far solved that very well.  When you step back and ask "what's the problem", you see a lot of very complex and excellent software is being written.  Real-time video editors, for example.  Amazing.   PhotoShop, amazing.  But programming has been around now, we're onto the next generation of coders.  How do we quickly bring existing software systems forward, using the "next generation" of developers?  Some developers may be reluctant to touch anything, which hinders innovation.   And as mentioned, I'm a strong believer in that "good software" does its task efficiently - so that it is function with as few hardware resources as possible (least RAM, least heat, least CPU -- overall less power).  In our small way, this directly supports the concepts of a sustainable society - I want good software that "sips" the processor, not hogs it and requires 300+ Watts.

I'm not sure how we get there -- I think AR or VR might be involved.  For example, if we could "virtualize" the software effort -- not so much to replace high level programming languages, but to augment how we depict software so that in real-time we can see the effects of our software -- what resources aren't being mutexed, what dependencies we're adding, how much burden we're adding to the overall memory/CPU foot print of our software, how many module inter-dependencies we are creating.   Sort of like an advancement onto syntax highlighting or auto-complete, a way to "look behind" the code -- visualize the thread of function names, where the declaration name might across calls, but it is fundamentally just "this block of memory."

I'm not sure if such a thing will ever be possible, or if it would actually be useful.  But these are the kinds of things I ponder about - inevitably, something must come after "high level languages", and what will that be?

